##第二部分 单机数据库的实现

#1.数据库
Redis服务器将所有数据库都保存在服务器状态redisServer结构的db数组中，db数组的每个项都是一个redisDb结构
每个redisDb结构代表一个数据库
strcut redisServer{
    //...
    //一个数组，保存着服务器中的所有数据库
    redisDb *db;
    //服务器的数据库数量
    int dbnum;
    //...
};
在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库
dbnum属性的值由服务器配置的database选项决定，默认情况下为16

切换数据库
每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标
数据库就会成为这些命令的操作对象。默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以
执行select命令来切换目标数据库

在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个
指向redisDb结构的指针：
typedef struct redisClient{
    //...
    //记录客户端当前正在使用的数据库
    redisDb *db;
    //...
}redisClient;
redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库
通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是select
命令的实现原理
为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT
命令，显示切换到指定的数据库，然后才执行别的命令

数据库键空间
Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redisDb结构表示，其中redisDb结构
dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间
typedef struct redisDb {
    //...
    //数据库键空间，保存着数据库中的所有键值对
    dict *dict;
    //...
}redisDb;

因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库
中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的。

读写键空间时的维护操作
当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作
其中包括：
    在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间
    命中次数和键空间不命中底数，这两个值可以在info state命令的keyspace_hits属性和
    keyspace_misses属性中查看
    在读取一个键之后，服务器会 更新键的LRU(最后一次使用)时间，这个值可以用于计算键的闲置时间
    如果服务器在读取一个键时发现该键已经过期了，那么服务器会先删除这个过期键，然后才执行余下的其他操作
    如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记
    为肮，从而让事务程序注意到这个键已经被修改过
    服务器每次修改了一个键之后，都会对脏键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作
    如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知
    
设置键的生存时间或过期时间
通过expire命令或者pexpire命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live）
TTL,在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键

setex命令可以在设置一个字符串键的同时为键设置过期时间

TTL命令和PTTL命令接受一个带有生存时间或过期时间的键，返回这个键的剩余生存时间

设置过期时间
EXPIRE key ttl命令用于将键key的生存时间设置为ttl秒
PEXPIRE key ttl命令用于将键key的生存时间设置为ttl毫秒
EXPIREAT key timestamp命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳
PEXPIREAT key timestamp命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳

实际上EXPIRE、PEXPIRE、EXPIREAT 三个命令都是使用PEXPIREAT命令来实现的


保存过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典
typedef struct redisDb {
    //...
    //过期字典，保存着键的过期时间
    dict *expires;
    //...
}redisDb;


移除过期时间
persist命令可以移除一个键的过期时间

计算并返回剩余生存时间
ttl
pttl

过期键的判定
通过过期字典，程序可以用以下步骤检查一个给定键是否过期：
  检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间
  检查当前UNIX时间戳是否大于键的过期时间，如果是的话，那么键已经过期，否则的话，键未过期
  
  
过期键删除策略
过期键什么时候会被删除？
1>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
2>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除改键，否则就返回改键
3>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除过少过期键，以及要检查多少个数据库，则由算法决定。


定时删除：
对CPU时间是最不友好的。在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是
CPU时间紧张的情况下，无疑会对服务器的响应时间和吞吐量造成影响
除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个
事件的时间复杂度为O(N)——并不能高效地处理大量时间事件


惰性删除：
对内存不友好

定期删除：
定期删除策略是前两种策略的一种整合和折中
定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间影响
除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。

Redis的过期删除策略
Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好
地在合理使用CPU时间和避免浪费内存空间之间取得平衡。

惰性删除策略由expireifNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查


过期键的定期删除策略由activeExpireCycle函数实现
每当Redis的服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定
的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，比删除其中的过期键


AOF、RDB和复制功能对过期键的处理

生成RDB文件：
在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已
过期的键不会被保存到新创建的RDB文件中

载入RDB文件：
在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：
   如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键
   会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。
   如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入
   到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，
   过期键对载入RDB文件的从服务器也不会造成影响。
   
   
   
AOF文件写入
当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么
AOF文件不会因为这个过期键而产生任何影响。
当过期键被惰性删除或定期删除之后，程序会向AOF文件追加一条DEL命令，来显示地记录该键以被删除

AOF重写
和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写
后的AOF文件中。


复制
当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制
  主服务器在删除一个过期键之后，会显式地向从服务器发送一个DEL命令，告知从服务器删除这个过期键。
  从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来
  处理过期键
  从服务只有在接到主服务器发来的DEL命令之后，才会删除过期键。
  
  
数据库通知
数据库通知是Redis2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者
模式，来获知数据库中键的变化，以及数据库中命令的执行情况。

这一类关注"某个键执行了什么命令"的通知称为键空间通知
除此之外，还有另一类称为键事件通知的通知，他们关注的是“某个命令被什么键执行了”

服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型

发送通知
发送数据库通知的功能是由notifyKeyspaceEvent函数实现的
void notifyKeyspaceEvent(int type,char *event,robj *key,int dbid);
函数type参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是
服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知
event\key\dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据type
参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名


#2 RDB持久化
我们将服务器中的非空数据库以及它们的键值对统称为数据库状态
RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以
将某个时间点上的数据库状态保存到一个RDB文件中，该文件是一个经过压缩的
二进制文件，通过该文件可以还原生成RDB文件的数据库状态

RDB文件的创建与载入
有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。
SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器
进程阻塞期间，服务器不能处理任何命令请求
和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，
然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求
创建RDB文件的实际工作由rdbSave函数完成，SAVE命令和BGSAVE命令会以不同的方式
调用这个函数

RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于
载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动
载入RDB文件

另外值得一提的是，因为AOF文件更新频率通常比RDB文件更新频率高，所以：
  如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态
  只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态
  
在BGSAVE命令执行期间：
客户端发送的SAVE命令会被服务器拒绝，避免同时执行rdbSave调用，防止产生竞争条件
客户端发送的BGSAVE命令会被服务器拒绝，避免竞争
如果客户端发送BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行
如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝
因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这
两个命令在操作方面并没有什么冲突的地方，不能同时执行他们只是一个性能方面的
考虑

服务器在载入RDB文件期间，会一直处于阻塞状态，知道载入工作完成为止

自动间隔性保存
save 900 1
save 300 10
save 60 10000
这些条件被保存在服务器状态redisServer结构的saveparams属性：
struct redisServer {
    //...
    //记录了保存条件的数组
    struct saveparam *saveparam;
    //...
};
saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，
每个saveparam结构都保存了一个save选项设置的保存条件
struct saveparam {
    //秒数
    time_t seconds;
    //修改数
    int changes;
}

除了saveparams数组之外，服务器还维持着一个dirty计数器，以及一个lastsave
属性：
dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器
对数据库状态进行了多少次修改
lastsave属性时一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令
或者BGSAVE命令的时间。
struct redisServer {
    //...
    //修改计数器
    long dirty;
    //上一次执行保存时间
    time_t lastsave;
    
    //...
};

Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该
函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所
设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令


RDB文件结构
一个完整RDB文件所包含的各个部分
REDIS db_version databases EOF check_sum

RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着“REDIS”五个字符，通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件
db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号
databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据
   如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节
   如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存的键值对数量、类型和内容不同，这个部分的长度也会有所不同
EOF常量的长度为1字节，这个常量标志RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。
check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入
RDB文件时，会将载入数据所计算出的校验与check_sum所记录的校验和进行对比，依次来检查RDB文件是否有出错或者损坏的情况出现。


databases部分
SELECTDB db_number key_value_pairs

key_value_pairs部分
不带过期时间：
TYPE key value
TYPE常量代表了一种对象类型或者底层编码，程序会根据TYPE的值来决定如何读入和解释value的数据

带过期时间：
EXPIRETIME_MS ms TYPE key value

RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构，长度也会有所不同


分析RDB文件
od命令来分析Redis服务器产生的RDB文件，该命令可以用给定的格式转存并打印输入文件。




#3 AOF持久化

与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的

AOF持久化的实现
AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤
当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态
的aof_buf缓冲区的末尾
struct redisServer {
    //...
    //AOF缓冲区
    sds aof_buf;
    //...
};

AOF文件的写入与同步
Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，
以及客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。



因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次
结束一个事件循环之前，它都会调用flushAppendOnlyFile函数
flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定，
当为always时 将aof_buf缓冲区中的所有内容写入并同步到AOF文件中
当为everysec   将aof_buf缓冲区中的所有内容写入到AOF文件中，如果上次同步AOF文件的时间距离现在超过一秒钟，
          那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的
当为no 将aof_buf缓冲区中的所有内容写入到AOF中，但并不对AOF文件进行同步，何时同步由操作系统来决定

AOF文件的载入与数据还原
因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面
保存的写命令，就可以还原服务器关闭之前的数据库状态。
步骤：
1>创建一个不带网络连接的伪客户端（fake client）:因为Redis的命令只能在客户端上下文执行，而载入
AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务使用了一个没有网络连接的伪客户端来执行AOF
文件保存的写命令
2>从AOF文件中分析并读取出一条写命令
3>使用伪客户端执行被读出的写命令
4>一直执行步骤2和步骤3，知道AOF文件中的所有写命令都被处理完毕为止

AOF重写
随着时间推移AOF文件体积膨胀，为了解决这个问题，Redis提供 了AOF文件重写（rewrite）功能，通过该
功能，Redis服务器可以创建一个新AOF文件来代替现有AOF文件，新旧两个文件所保存的数据库状态相同，但
新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多


AOF文件重写的实现
首先从数据库重读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是
AOF重写功能的实现原理。

实际上，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合
这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD
常量，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。

REDIS_AOF_REWRITE_ITEMS_PER_CMD为64

AOF后台重写
AOF重写程序aof_rewrite函数将在子进程中执行，因为
子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求
子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性

在子进程执行AOF重写期间，服务器进程需要执行以下三个工作
执行客户端发来的命令
将执行后的写命令追加到AOF缓冲区
将执行后的写命令追加到AOF重写缓冲区

这样一来可以保证：
AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。
从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面

当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并
执行以下工作：
1>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态和服务器当前的数据库状态一致
2>对新AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换
这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。
在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF
后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响将到了最低

以上就是BGREWRITEAOF命令的实现原理

# 事件

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：
文件事件(file event):Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文本事件
                   就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件
                   事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作
时间事件(time event):Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间
                   事件就是服务器对这类定时操作的抽象。
                   
                                      
文件事件
Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器(file event handler):
    文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
    当被监听的套接字准备好执行连接应答(accept)、读取（read）、写入（write）、关闭（close）等操作
    时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件

虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了
高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的摩卡进行对接，这保持了Redis内部
单线程设计的简单性。    
    
    
文件事件处理器的够成
由四部分够成，分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher）,以及事件处理器

文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个
文本事件，因为一个服务器通常会连接多个套接字，多以多个文件事件有可能会并发地出席那。
I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。
尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，
然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的
事件被处理完毕之后(该套接字为事件所关联的事件处理器执行完毕)，I/O多路复用程序才会继续向文件事件分派器
传送下一个套接字

I/O多路复用程序的实现
Redis的I/O多路复用程序的所有功能都是通过包装常见的select\epoll\evport和kqueue这些I/O多路复用
函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件。
因为Redis为每个I/O多路复用函数库都实现了相同的API，所以I/O多路复用程序的底层实现是可以互换的。
Redis在I/O多路复用程序的实现源码中用#include宏定义了相应的规则，程序会在编译时自动选择系统中性能
最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现

事件类型
I/O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时
产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，
才处理AE_WRITABLE事件。

文件事件的处理器
Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：
  为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联应答处理器
  为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器
  为了向客户端返回命令的执行结果，服务器要为客户端套接字管理命令回复处理器
  当主服务器和从服务器进行赋值操作时，主从服务器都需要关联特别为复制功能编写的复制处理器


时间事件
Redis的时间事件分为以下两类：
定时事件：
周期性事件

一个时间事件主要由以下三个属性组成：
id:服务器为时间事件创建的全局唯一ID(标识号)。ID号按从小到达的顺序递增，新事件的ID号比旧事件的ID号要大
when:毫秒精度的UNIX时间戳，记录时间事件的到达时间
timeProc:时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件

一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：
如果事件处理器返回ae.h/AE_NOMORE,那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达
如果事件处理器返回一个非AE_NORMOE的整数值，那么这个事件为周期性事件

当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间
之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对
这个时间事件进行更新，让这个事件在30毫秒之后再次到达。


















































