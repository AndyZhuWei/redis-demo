##第二部分 单机数据库的实现

#1.数据库
Redis服务器将所有数据库都保存在服务器状态redisServer结构的db数组中，db数组的每个项都是一个redisDb结构
每个redisDb结构代表一个数据库
strcut redisServer{
    //...
    //一个数组，保存着服务器中的所有数据库
    redisDb *db;
    //服务器的数据库数量
    int dbnum;
    //...
};
在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库
dbnum属性的值由服务器配置的database选项决定，默认情况下为16

切换数据库
每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标
数据库就会成为这些命令的操作对象。默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以
执行select命令来切换目标数据库

在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个
指向redisDb结构的指针：
typedef struct redisClient{
    //...
    //记录客户端当前正在使用的数据库
    redisDb *db;
    //...
}redisClient;
redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库
通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是select
命令的实现原理
为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT
命令，显示切换到指定的数据库，然后才执行别的命令

数据库键空间
Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redisDb结构表示，其中redisDb结构
dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间
typedef struct redisDb {
    //...
    //数据库键空间，保存着数据库中的所有键值对
    dict *dict;
    //...
}redisDb;

因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库
中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的。

读写键空间时的维护操作
当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作
其中包括：
    在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间
    命中次数和键空间不命中底数，这两个值可以在info state命令的keyspace_hits属性和
    keyspace_misses属性中查看
    在读取一个键之后，服务器会 更新键的LRU(最后一次使用)时间，这个值可以用于计算键的闲置时间
    如果服务器在读取一个键时发现该键已经过期了，那么服务器会先删除这个过期键，然后才执行余下的其他操作
    如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记
    为肮，从而让事务程序注意到这个键已经被修改过
    服务器每次修改了一个键之后，都会对脏键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作
    如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知
    
设置键的生存时间或过期时间
通过expire命令或者pexpire命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live）
TTL,在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键

setex命令可以在设置一个字符串键的同时为键设置过期时间

TTL命令和PTTL命令接受一个带有生存时间或过期时间的键，返回这个键的剩余生存时间

设置过期时间
EXPIRE key ttl命令用于将键key的生存时间设置为ttl秒
PEXPIRE key ttl命令用于将键key的生存时间设置为ttl毫秒
EXPIREAT key timestamp命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳
PEXPIREAT key timestamp命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳

实际上EXPIRE、PEXPIRE、EXPIREAT 三个命令都是使用PEXPIREAT命令来实现的


保存过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典
typedef struct redisDb {
    //...
    //过期字典，保存着键的过期时间
    dict *expires;
    //...
}redisDb;


移除过期时间
persist命令可以移除一个键的过期时间

计算并返回剩余生存时间
ttl
pttl

过期键的判定
通过过期字典，程序可以用以下步骤检查一个给定键是否过期：
  检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间
  检查当前UNIX时间戳是否大于键的过期时间，如果是的话，那么键已经过期，否则的话，键未过期
  
  
过期键删除策略
过期键什么时候会被删除？
1>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
2>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除改键，否则就返回改键
3>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除过少过期键，以及要检查多少个数据库，则由算法决定。


定时删除：
对CPU时间是最不友好的。在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是
CPU时间紧张的情况下，无疑会对服务器的响应时间和吞吐量造成影响
除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个
事件的时间复杂度为O(N)——并不能高效地处理大量时间事件


惰性删除：
对内存不友好

定期删除：
定期删除策略是前两种策略的一种整合和折中
定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间影响
除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。

Redis的过期删除策略
Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好
地在合理使用CPU时间和避免浪费内存空间之间取得平衡。

惰性删除策略由expireifNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查


过期键的定期删除策略由activeExpireCycle函数实现
每当Redis的服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定
的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，比删除其中的过期键


AOF、RDB和复制功能对过期键的处理

生成RDB文件：
在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已
过期的键不会被保存到新创建的RDB文件中

载入RDB文件：
在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：
   如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键
   会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。
   如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入
   到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，
   过期键对载入RDB文件的从服务器也不会造成影响。
   
   
   
AOF文件写入
当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么
AOF文件不会因为这个过期键而产生任何影响。
当过期键被惰性删除或定期删除之后，程序会向AOF文件追加一条DEL命令，来显示地记录该键以被删除

AOF重写
和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写
后的AOF文件中。


复制
当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制
  主服务器在删除一个过期键之后，会显式地向从服务器发送一个DEL命令，告知从服务器删除这个过期键。
  从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来
  处理过期键
  从服务只有在接到主服务器发来的DEL命令之后，才会删除过期键。
























































































