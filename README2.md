##第二部分 单机数据库的实现

#1.数据库
Redis服务器将所有数据库都保存在服务器状态redisServer结构的db数组中，db数组的每个项都是一个redisDb结构
每个redisDb结构代表一个数据库
strcut redisServer{
    //...
    //一个数组，保存着服务器中的所有数据库
    redisDb *db;
    //服务器的数据库数量
    int dbnum;
    //...
};
在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库
dbnum属性的值由服务器配置的database选项决定，默认情况下为16

切换数据库
每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标
数据库就会成为这些命令的操作对象。默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以
执行select命令来切换目标数据库

在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个
指向redisDb结构的指针：
typedef struct redisClient{
    //...
    //记录客户端当前正在使用的数据库
    redisDb *db;
    //...
}redisClient;
redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库
通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是select
命令的实现原理
为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT
命令，显示切换到指定的数据库，然后才执行别的命令

数据库键空间
Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redisDb结构表示，其中redisDb结构
dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间
typedef struct redisDb {
    //...
    //数据库键空间，保存着数据库中的所有键值对
    dict *dict;
    //...
}redisDb;

因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库
中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的。

读写键空间时的维护操作
当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作
其中包括：
    在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间
    命中次数和键空间不命中底数，这两个值可以在info state命令的keyspace_hits属性和
    keyspace_misses属性中查看
    在读取一个键之后，服务器会 更新键的LRU(最后一次使用)时间，这个值可以用于计算键的闲置时间
    如果服务器在读取一个键时发现该键已经过期了，那么服务器会先删除这个过期键，然后才执行余下的其他操作
    如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记
    为肮，从而让事务程序注意到这个键已经被修改过
    服务器每次修改了一个键之后，都会对脏键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作
    如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知
    
设置键的生存时间或过期时间
通过expire命令或者pexpire命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live）
TTL,在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键

setex命令可以在设置一个字符串键的同时为键设置过期时间

TTL命令和PTTL命令接受一个带有生存时间或过期时间的键，返回这个键的剩余生存时间

设置过期时间
EXPIRE key ttl命令用于将键key的生存时间设置为ttl秒
PEXPIRE key ttl命令用于将键key的生存时间设置为ttl毫秒
EXPIREAT key timestamp命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳
PEXPIREAT key timestamp命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳

实际上EXPIRE、PEXPIRE、EXPIREAT 三个命令都是使用PEXPIREAT命令来实现的


保存过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典
typedef struct redisDb {
    //...
    //过期字典，保存着键的过期时间
    dict *expires;
    //...
}redisDb;


移除过期时间
persist命令可以移除一个键的过期时间

计算并返回剩余生存时间
ttl
pttl

过期键的判定
通过过期字典，程序可以用以下步骤检查一个给定键是否过期：
  检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间
  检查当前UNIX时间戳是否大于键的过期时间，如果是的话，那么键已经过期，否则的话，键未过期
  
  
过期键删除策略
过期键什么时候会被删除？
1>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
2>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除改键，否则就返回改键
3>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除过少过期键，以及要检查多少个数据库，则由算法决定。


定时删除：
对CPU时间是最不友好的。在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是
CPU时间紧张的情况下，无疑会对服务器的响应时间和吞吐量造成影响
除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个
事件的时间复杂度为O(N)——并不能高效地处理大量时间事件


惰性删除：
对内存不友好

定期删除：
定期删除策略是前两种策略的一种整合和折中
定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间影响
除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。

Redis的过期删除策略
Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好
地在合理使用CPU时间和避免浪费内存空间之间取得平衡。

惰性删除策略由expireifNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查


过期键的定期删除策略由activeExpireCycle函数实现
每当Redis的服务器周期性操作serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定
的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，比删除其中的过期键


AOF、RDB和复制功能对过期键的处理

生成RDB文件：
在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已
过期的键不会被保存到新创建的RDB文件中

载入RDB文件：
在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：
   如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键
   会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。
   如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入
   到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，
   过期键对载入RDB文件的从服务器也不会造成影响。
   
   
   
AOF文件写入
当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么
AOF文件不会因为这个过期键而产生任何影响。
当过期键被惰性删除或定期删除之后，程序会向AOF文件追加一条DEL命令，来显示地记录该键以被删除

AOF重写
和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写
后的AOF文件中。


复制
当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制
  主服务器在删除一个过期键之后，会显式地向从服务器发送一个DEL命令，告知从服务器删除这个过期键。
  从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来
  处理过期键
  从服务只有在接到主服务器发来的DEL命令之后，才会删除过期键。
  
  
数据库通知
数据库通知是Redis2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者
模式，来获知数据库中键的变化，以及数据库中命令的执行情况。

这一类关注"某个键执行了什么命令"的通知称为键空间通知
除此之外，还有另一类称为键事件通知的通知，他们关注的是“某个命令被什么键执行了”

服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型

发送通知
发送数据库通知的功能是由notifyKeyspaceEvent函数实现的
void notifyKeyspaceEvent(int type,char *event,robj *key,int dbid);
函数type参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是
服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知
event\key\dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据type
参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名


#2 RDB持久化
我们将服务器中的非空数据库以及它们的键值对统称为数据库状态
RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以
将某个时间点上的数据库状态保存到一个RDB文件中，该文件是一个经过压缩的
二进制文件，通过该文件可以还原生成RDB文件的数据库状态

RDB文件的创建与载入
有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。
SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器
进程阻塞期间，服务器不能处理任何命令请求
和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，
然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求
创建RDB文件的实际工作由rdbSave函数完成，SAVE命令和BGSAVE命令会以不同的方式
调用这个函数

RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于
载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动
载入RDB文件

另外值得一提的是，因为AOF文件更新频率通常比RDB文件更新频率高，所以：
  如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态
  只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态
  
在BGSAVE命令执行期间：
客户端发送的SAVE命令会被服务器拒绝，避免同时执行rdbSave调用，防止产生竞争条件
客户端发送的BGSAVE命令会被服务器拒绝，避免竞争
如果客户端发送BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行
如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝
因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这
两个命令在操作方面并没有什么冲突的地方，不能同时执行他们只是一个性能方面的
考虑

服务器在载入RDB文件期间，会一直处于阻塞状态，知道载入工作完成为止

自动间隔性保存
save 900 1
save 300 10
save 60 10000
这些条件被保存在服务器状态redisServer结构的saveparams属性：
struct redisServer {
    //...
    //记录了保存条件的数组
    struct saveparam *saveparam;
    //...
};
saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，
每个saveparam结构都保存了一个save选项设置的保存条件
struct saveparam {
    //秒数
    time_t seconds;
    //修改数
    int changes;
}

除了saveparams数组之外，服务器还维持着一个dirty计数器，以及一个lastsave
属性：
dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器
对数据库状态进行了多少次修改
lastsave属性时一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令
或者BGSAVE命令的时间。
struct redisServer {
    //...
    //修改计数器
    long dirty;
    //上一次执行保存时间
    time_t lastsave;
    
    //...
};

Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该
函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所
设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令



































































