共有四部分：数据结构与对象、单机数据库的实现、多机数据库的实现和独立功能的实现
# 第一部分 数据结构与对象
## 第2章 简单动态字符串
   Redis没有直接使用C语言传统的字符串表示（以空字符串结尾的字符数组），而是自己构建了一种名为
简单动态字符串（simple dynamic string,SDS）的抽象类型，并将SDS用作Redis的默认字符串表示

   在Redis里面，C字符只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如打印日志
除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区(buffer)：AOF模块中的AOF缓冲区，以及客户端状态中
的输入缓冲区，都是由SDS实现。

C语言使用的字符串表示方式，并不能满足Redis对字符串在安全性、效率以及功能方面的要求。

### 2.1 SDS的定义
```
struct sdshdr {
 //记录buf数组中已使用字节的数量
 //等于SDS所保存字符串的长度
 int len;
 
 //记录buf数组中未使用字节的数量
 int free;
 
 //字节数组，用于保存字符串
 char buf[];

}
```

SDS遵循C字符串以空字符('\0')结尾的惯例是可以直接重用一部分C字符串函数库里面的函数
注意：空字符串'\0'是不计算在len属性内，由SDS函数自动添加，对使用者透明

### 2.2 SDS与C字符串的区别
根据传统，C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符串'\0'.
C语言使用的这种简单的字符串表示方式，并不能满足Redis对字符串在安全性、效率以及功能方面的要求。

#### 2.2.1 常数复杂度获取字符串长度
C字符串并不记录字符串长度，需要遍历整个字符，时间复杂度为O(N),
SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O(1)
所以获取字符串长度的工作不会成为Redis的性能瓶颈，即使我们对一个非常长的字符串键反复执行strlen命令，也不会对系统造成任何影响，因为strlen命令的复杂度仅为O(1)
#### 2.2.2 杜绝缓冲区溢出 
   C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳strc字符串中的所有内容，而一旦这个假定不成立时，
就会产生缓存区溢出。
   与C字符串不同，SDS的空间分配策略完全杜绝了发送缓存区溢出的可能性：SDS函数在执行字符串拼接的时候会先检查空间是否足够，如果不够会自动进行扩容
#### 2.2.3 减少修改字符串时带来的内存重分配次数
每次增长或缩短一个C字符串，程序都要对保存C字符串的数组进行一次内存重分配操作：
<1.如果是增长操作，程序需要先通过重分配来扩展数据的空间，否则就会产生缓存区溢出
<2.如果是缩短字符串操作，程序需要通过重分配释放字符串不再使用的空间，否则就会产生内存泄漏
以上都需要进行内存重分配，这个动作涉及复杂的算法，是个耗时操作。如果这个动作发生频繁会对性能造成影响，为了避免这种缺陷，SDS通过未使用空间解除了字符串长度
和底层数组长度之间的关联，在SDS中，buf数组的长度不一定就是字符数量加一。

通过为使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略
  **1.空间预分配**
如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。
如果对SDS进行修改之后，SDS的长度将大于等于1MB,那么程序会分配1MB的未使用空间。
  
在扩展SDS空间之前，SDS API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用空间，而无须执行内存重分配。
  
  **2.惰性空间释放**
用于优化SDS字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，
并等待将来使用。与此同时，SDS也提供了相应的API,让我们可以在有需要时，真正地释放SDS的未使用空间。
#### 2.2.4 二进制安全
   C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符串，否则最先被程序读入的空字符串被误认为是字符串结尾。
   SDS的API都是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，
数据在写入时是什么样的，它被读取时就是什么样。这也是我们将SDS的buf属性称为字节数组的原因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。
#### 2.2.5 兼容部分C字符串函数
#### 2.2.6 总结：
images/C字符串与SDS之间的区别.png

### 2.3 SDS API

### 2.4 重点回顾
1.Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS(Simple Dynamic String，简单动态字符串)作为字符串表示。
2.比起C字符串，SDS具有以下优点：
1>常数复杂度获取字符串长度
2>杜绝缓冲区溢出
3>减少修复字符串长度时所需的内存重分配次数
4>二进制安全
5>兼容部分C字符串函数
  



## 第3章 链表
   因为Redis使用的C语言并没有内置这种数据结构，所以Redis构建了自己的链表实现。
   链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis
就会使用链表作为列表键的底层实现。
   除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还是用链表来保存多个客户端的状态信息，
以及使用链表来构建客户端输出缓冲区。

### 3.1 链表和链表节点的实现
```
typedef struct listNode {
    //前置节点
    struct listNode *prev;
    
    //后置节点
    struct listNode *next;
    
    //节点的值
    void *value
} listNode;
```
多个listNode可以通过prev和next指针组成双端链表
```
typedef struct list {
    //表头节点
    listNode *head;
    
    //表尾节点
    listNode *tail;
    
    //链表所包含的节点数量
    unsigned long len;
    
    //节点值复制函数
    void *(*dup)(void *ptr);
    
    //节点值释放函数
    void (*free)(void *ptr);
    
    //节点值对比函数
    int (*match)(void *ptr,void *key);
} list;
```

Redis的链表实现的特性可以总结如下：
1> 双端:链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)
2> 无环:表头节点的prev指针和表尾节点和next指针都指向NULL，对链表的访问以NULL为终点
3> 带表头指针和表尾指针:通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)
4> 带链表长度计数器: 程序获取链表中节点数量的复杂度为O(1)
5> 多态:链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种
不同类型的值

### 3.2 链表和链表节点的API

### 3.3 重点回顾
1> 链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。
2> 每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。
3> 每个链表使用一个list结构来表示，这个结构带有表头节点指针，表尾节点指针，以及链表长度等信息
4> 因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。
5> 通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。


## 第4章 字典
   字典，又称为符号表、关联数组或映射，是一种用于保存键值对的抽象数据结构。Redis的数据库就是使用字典来作为底层实现的。除了用来表示数据库之外，
字典还是哈希键的底层实现之一。

### 4.1 字典的实现
  Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。
  
#### 4.1.1 哈希表
```
typedef struct dictht {
    //哈希表数组
    dictEntry **table;
    
    //哈希表大小
    unsigned long size;
    
    //哈希表大小掩码，用于计算索引值
    //总是等于size-1
    unsigned long sizemask;
    
    //该哈希表已有节点的数量
    unsigned long used;
} dictht;
```
table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针
#### 4.1.2 哈希表节点
哈希表节点使用dictEntry结构表示
```
typedef struct dictEntry {
    //键
    void *key;
    
    //值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    } v;
    
    //指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```
key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。
next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突(collision)的问题。
#### 4.1.3 字典
```
typedef struct dict {
    //类型特定函数
    dictType *type;
    
    //私有数据
    void *privdata;
    
    //哈希表
    dictht ht[2];
    
    //rehash索引
    //当rehash不在进行时，值为-1
    int rehashidx;
} dict;
```
   type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置
   ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表。一般情况下，字典只使用ht[0]哈希表，
ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。除了ht[1]之外，另一个和rehash有关的属性就是rehashidx,它记录了rehash目前的进度，
如果目前没有在进行rehash,那么它的值为-1

### 4.2 哈希算法
Redis计算哈希值和索引的方法如下：
hash=dict->type->hashFunction(key);
使用哈希表的sizemask属性和哈希值，计算出索引值，根据情况不同，ht[x]可以是
ht[0]或者ht[1]
index=hash&dict->ht[x].sizemask;
Redis使用MurmurHash2算法来计算键的哈希值

### 4.3 解决键冲突
链地址法
(因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置(复杂度为O(1)),排在其他已有节点的前面。)

### 4.4 rehash
为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。
扩展和收缩哈希表的工作可以通过执行rehash操作来完成。Redis对字典的哈希表执行rehash的步骤如下：
1>为字典的ht[1]哈希表分配空间，这个哈希表空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：
   如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2的n次放幂
   如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2的n次幂
2>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
3>当ht[0]包含的所有键值对都迁移到了ht[1]之后(ht[0]变为空表)，释放ht[0],将ht[1]设置为ht[0],并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。

**哈希表的扩展与缩容**
  当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：
1)服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1
2)服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令,并且哈希表的负载因子大于等于5
  其中哈希表的负载因子可以通过公式：
负载因子=哈希表已保存节点数量/哈希表大小
load_factory=ht[0].used/ht[0].size

根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，
Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率所以在子进程存在期间，服务器会提高执行扩展操作所需的
负载因子，从而尽可能避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存

另一个，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

### 4.5 渐进性rehash

   扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。
如果一次性性rehash,因为数据量太多庞大的计算量会造成服务器一段时间内停止服务.


以下是哈希表渐进式rehash的详细步骤:
1>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
2>在字典中维持一个索引计数器变量rehashidx,并将它的值设置为0，表示rehash工作正式开始
3>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到
    ht[1],当rehash工作完成之后，程序将rehashidx属性的值增一。
4>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已经完成。

### 4.6 字典API


### 4.7 重点回顾
1> 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键
2> Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。
3> 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值
4> 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表
5> 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。






## 第5章 跳跃表
跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。

在大部分情况下，跳跃表的效率可以和平衡树相媲美，而且实现比平衡树简单

   Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量表较多，又或者有序集合中元素的成员是比较长的字符串时，
Redis就会使用跳跃表来作为有序集合键的底层实现。

和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。
### 5.1 跳跃表的实现
#### 5.1.1 跳跃表节点
```
typedef struct zskiplistNode {
  //层
  struct zskiplistLevel {
    //前进指针
    struct zskiplistNode *forward;
    
    //跨度
    unsigned int span;
  } level[];
  
  //后退指针
  struct zskiplistNode *backward;
  
  //分值
  double score;
  
  //成员对象
  robj *obj;
} zskiplistNode;
```
**层**
**前进指针**
**跨度**
   遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是
目标节点在跳跃表中的排位。
**后退指针**
**分值和成员**
#### 5.1.2 跳跃表
```
typedef struct zskiplist{
  //表头节点和表尾节点
  struct zskiplistNode *header,*tail;
  //表中节点的数量（表头节点不计算在内）
  ussigned long length;
  
  //表中层数最大的节点的层数（表头节点的层数不计算在内）
  int level;
}zskiplist;

```
### 5.2 跳跃表API
### 5.3 重点回顾
1> 跳跃表是有序集合的底层实现之一
2> Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode
   则用于表示跳跃表节点
3> 每个跳跃表节点的层高都是1至32之间的随机数
4> 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
5> 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。


## 第6章 整数集合
整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合键的底层实现

### 6.1 整数集合的实现
整数集合是Redis用于保存整数的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素
```
typedef struct intset {
 //编码方式
 uint32_t encoding;
 //集合包含的元素数量
 uint32_t length;
 //保存元素的数组
 int8_t contents[];
}intset;
```
   虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决与
encoding属性的值
   contents数组按从小到大的顺序保存着集合中的五个元素

### 6.2 升级
   每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级(upgrade),
然后才能将新元素添加到整数集合里面。
   因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)
### 6.3 升级的好处
1> 提升整数集合的灵活性
2> 尽可能地节约内存
### 6.4 降级
整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

### 6.5 整数集合API
### 6.6 重点回顾
1> 整数集合是集合键的底层实现之一
2> 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型
3> 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。
4> 整数集合只支持升级操作，不支持降级操作




## 第7章 压缩列表
   压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，那么
Redis就会使用压缩列表来做列表键和的底层实现。
   另外，当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的
底层实现。

### 7.1 压缩列表的够成
   压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个
字节数组或者一个整数值。

zlbytes zltail zllen entry1 entry2 ... entryN zlend
zlbytes:记录整个压缩列表占用的内存字节数
zltail:记录压缩列表表尾节点距离压缩列表的起始地址有多少字节。
zllen:记录了压缩列表包含的节点数量
entryX：列表节点
zlend:特殊值，用于标记压缩列表的末端

### 7.2 压缩列表节点的各个组成部分
previous_entry_length encoding content

#### 7.2.1 previous_entry_length
节点previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。
#### 7.2.2 encoding
节点encoding属性记录了节点的content属性所保存数据的类型以及长度
#### 7.2.3 content

### 7.3 连锁更新

### 7.4压缩列表API

### 7.5重点回顾
1> 压缩列表是一种为节约内存而开发的顺序型数据结构
2> 压缩列表被用作列表键和哈希键的底层实现之一
3> 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或整数值。
4> 添加新节点到压缩表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高

## 第8章 对象
   前面介绍了Redis用到的所有主要数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合。Redis并没有直接使用这些数据结构来实现
键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。
每种对象都用到了至少一种我们前面所介绍的数据结构。

### 8.1对象的类型与编码
  Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，
另一个对象用作键值对的值

Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性
```
typedef struct redisObject {
    //类型
    unsigned type:4;
    //编码
    unsigned encoding:4;
    //指向底层实现数据结构的指针
    void *ptr;
    //...
    
}robj;
```
#### 8.1.1 类型
type属性可以是一下类型常量中的一个
REDIS_STRING 字符串对象 type命令输出为string
REDIS_LIST 列表对象     type命令输出为list
REDIS_HASH 哈希对象     type命令输出为hash
REDIS_SET 集合对象      type命令输出为set
REDIS_ZSET 有序集合对象  type命令输出为zset

对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。
因此：
当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”
当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”
TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型

#### 8.1.2 编码和底层实现
2>编码和底层实现
对象ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定

编码常量                       底层数据结构
REDIS_ENCODING_INT          long类型的正数
REDIS_ENCODING_EMBSTR       embstr编码的简单动态字符串
REDIS_ENCDING_RAW           简单动态字符串
REDIS_ENCODING_HT           字典
REDIS_ENCODING_LINKEDLIST   双端链表
REDIS_ENCODING_ZIPLIST      压缩列表
REDIS_ENCODING_INTSET       正数集合
REDIS_ENCODING_SKIPLIST     跳跃表和字典

每种类型的对象都至少使用两种不同的编码

类型                编码                      对象
REDIS_STRING       REDIS_ENCODING_INT       使用整数值实现的字符串对象
REDIS_STRING       REDIS_ENCODING_EMBSTR    使用embstr编码的简单动态字符串实现的字符串对象
REDIS_STRING       REDIS_ENCODING_RAW       使用简单动态字符串实现的字符串对象
REDIS_LIST         REDIS_ENCODING_ZIPLIST   使用压缩列表实现的列表对象
REDIS_LIST         REDIS_ENCODING_LINKEDLIST使用双端链表实现的列表对象
REDIS_HASH         REDIS_ENCODING_ZIPLIST   使用压缩列表实现的哈希对象
REDIS_HASH         REDIS_ENCODING_HT        使用字典实现的哈希对象
REDIS_SET          REDIS_ENCODING_INTSET    使用整数集合实现的集合对象
REDIS_SET          REDIS_ENCODING_HT        使用字典实现的集合对象
REDIS_ZSET         REDIS_ENCODING_ZIPLIST   使用压缩列表实现的有序集合对象
REDIS_ZSET         REDIS_ENCODING_SKIPLIST  使用跳跃表和字典实现的有序集合对象

使用object encoding对不同编码的输出
对象所使用的底层数据结构             编码常量             OBJECT ENCODING 命令输出
整数                         REDIS_ENCODING_INT      "int"
embstr编码的简单动态字符串(SDS) REDIS_ENCODING_EMBSTR    "embstr"
简单动态字符串                 REDIS_ENCODING_RAW       "raw"
字典                         REDIS_ENCODING_HT         "hashtable"
双端链表                      REDIS_ENCODING_LINKEDLIST “linkedlist”
压缩列表                      REDIS_ENCODING_ZIPLIST    “ziplist”
整数集合                      REDIS_ENCODING_INTSET    "intset"
跳跃表和字典                  REDIS_ENCODING_SKIPLIST   “skiplist”

通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定编码，极大提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来
为一个对象设置不同的编码，从而优化对象在某一场景下的效率。
例子：
在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：
因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中
随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面

### 8.2 字符串对象
字符串对象的编码可以是int、raw或者embstrh
    如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void *转换成long）,
并将字符串对象的编码设置为int
    如果一个字符串对象保存的是一个字符串值，并这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象
的编码设置为raw
   如果一个字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值

   embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw
编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含
redisObject和sdshdr两个结构

使用embstr编码的字符串对象保存短字符串值有以下好处：
embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。
释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数
因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。

long double类型表示的浮点数在Redis中也是作为字符串值来保存的，在有需要的时候，程序会将保存在字符串对象里面的字符串值转换会浮点数值，执行其他操作，
然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面

#### 8.2.1 编码的转换
int编码的字符串对象和embstr编码的字符串对象在满足条件的情况下，会被转换为raw编码的字符串对象
例如：
通过append命令，向一个保存整数值的字符串对象追加了一个字符串值，因为追加操作只能对字符串值执行，所以程序会先将之前保存的整数值
10086转换成字符串值“10086”，然后再执行追加操作，操作的执行结果就是一个raw编码的、保存了字符串值的字符串对象。
另外，因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序(只有int编码的字符串对象和raw编码的字符串对象有这些程序)，
所以embstr编码的字符串对象实际上是只读的。我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr
转成raw,然后再执行修改命令。因为这个原因，embstr编码的字符串对象会在执行修改命令之后，总会变成一个raw编码的字符串对象

#### 8.2.2 字符串命令的实现

### 8.3 列表对象
列表对象的编码可以是ziplist或者linkedlist
ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。
另一个方面，linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素

字符串对象是Redis五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。

#### 8.3.1 编码转换
当列表对象可以同时满足一下两个条件时，列表对象使用ziplist编码：
列表对象保存的所有字符串元素的长度都小于64字节
列表对象保存的元素数量小于512个；
以上两个上限值是可以修改的

不能满足这两个条件的列表对象需要使用linkedlist编码
#### 8.3.2 列表命令的实现
### 8.4 哈希对象
哈希对象的编码可以是ziplist或者hashtable
ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，
然后在将保存了值的压缩列表节点推入到压缩列表表尾。
另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
字典的每个键都是一个字符串对象，对象中保存了键值对的键
字典的每个值都是一个字符串对象，对象中保存了键值对的值

#### 8.4.1 编码转换
当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：
哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
哈希对象保存的键值对数量小于512个
以上条件的上限值是可以修改的

不满足这两个条件的哈希对象需要使用hashtable编码
#### 8.4.2 哈希命令的实现


### 8.5 集合对象
集合对象的编码可以是intset或者hashtable
inset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面
另一方面，hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL

#### 8.5.1 编码的转换
当集合对象可以同时满足以下两个条件时，对象使用intset编码
集合对象保存的所有元素都是整数值
集合对象保存的元素数量不超过512个 （这个条件可以修改）
不能满足这两个条件的集合对象需要使用hashtable编码
#### 8.5.2 集合命令的实现

### 8.6 有序集合对象
有序集合的编码可以是ziplist或者skiplist
  ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，
而第二个元素则保存元素的分值
  压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。

skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表
```
typedef struct zset {
  zskiplist *zsl;
  dict *dict;
} zset;
```


zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性
保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作。比如
zrank、zrange等命令就是基于跳跃表API来实现的。

zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，字典的键保存了
元素成员，而字典的值则保存了元素的分值。


虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值。

#### 8.6.1 编码转换
当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：
有序集合保存的元素数据量小于128个
有序集合保存的所有元素成员的长度都小于64字节
以上条件可以修改

不满足以上两个条件的有序集合对象将使用skiplist编码
#### 8.6.2 有序集合命令的实现



### 8.7 类型检查与命令多态
Redis中用于操作键的命令基本上可以分为两种类型
其中一种命令可以对任何类型的键执行，比如DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等
而另一种命令只能对特定类型的键执行：比如
  set、get、append、strlen等命令只能对字符串键执行
  hdel、hset、hget、hlen等命令只能对哈希键执行
  rpush、lpop、linsert、llen等命令只能对列表键执行
  sadd、spop、sinter、scard等命令只能对集合键执行
  zadd、zcard、zrank、zscore等命令只能对有序集合键执行

#### 8.7.1 类型检查的实现
类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：
   在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令
   否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。
#### 8.7.2 多态命令的实现
Redis除了会根据值对象的类型来判断是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令
例如：
对于LLEN命令
如果列表对象的编码为ziplist,那么说明列表对象的实现为压缩列表，程序将使用ziplistLen函数来返回列表的长度
如果列表对象的编码为linkedlist,那么说明列表对象的实现为双端链表，程序将使用listLength函数来返回双端链表的长度。

借用面向对象方面的术语来说，我们可以认为LLEN命令是多态的。
实际上，我们可以将DEL、EXPIRE、TYPE等命令也称为多态命令 是基于类型的多态（一个命令可以同时用于处理多种不同类型的键）
而LLEN等都是基于编码的多态（一个命令可以同时用于处理多种不同编码）


### 8.8 内存回收
   因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数技术实现的内存回收机制，通过这一机制，程序可以通过
跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

每个对象的引用技术信息由redisObject结构的refcount属性记录
```
typedef struct redisObject {
 //...
 
 //引用计数
 int refcount;
}robj;
```
### 8.9 对象共享
除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。
  目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，
服务器就会使用这些共享对象，而不是新创建对象。
注意：创建共享字符串对象的数量可以通过配置进行修改

尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。

### 8.10 对象的空转时长
   除了前面介绍的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序
访问的时间.
```
typedef struct redisObject{
   //...
   unsigned lru:22;
   //...
} robj;
```
object idletime命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的
这个命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性
除了可以被object idletime命令打印出来之外，键的空转时长还有另外一项作用：
如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkyes_lru,那么当服务器占用的内存
数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存
### 8.11 重点回顾
1>Redis数据库中的每个键值对的键和值都是一个对象
2>Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的
  使用效率
3>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。
4>Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。
5>Redis会共享值为0到9999的字符串对象
6>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

















































































































































